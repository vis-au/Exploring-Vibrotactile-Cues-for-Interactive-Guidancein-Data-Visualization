{"version":3,"file":"range.js","sourceRoot":"","sources":["../../../../src/compile/scale/range.ts"],"names":[],"mappings":"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","sourcesContent":["import {SignalRef} from 'vega';\nimport {isArray, isNumber} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {\n  Channel,\n  COLOR,\n  FILL,\n  FILLOPACITY,\n  OPACITY,\n  ScaleChannel,\n  SCALE_CHANNELS,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEOPACITY,\n  STROKEWIDTH,\n  X,\n  Y\n} from '../../channel';\nimport {Config, getViewConfigDiscreteSize, getViewConfigDiscreteStep, ViewConfig} from '../../config';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  hasDiscreteDomain,\n  isContinuousToDiscrete,\n  isExtendedScheme,\n  Scale,\n  scaleTypeSupportProperty,\n  Scheme\n} from '../../scale';\nimport {isStep, LayoutSizeMixins} from '../../spec/base';\nimport * as util from '../../util';\nimport {isSignalRef, SchemeConfig, VgRange} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, makeExplicit, makeImplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'scheme'];\n\nfunction getSizeType(channel: ScaleChannel) {\n  return channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n}\n\nexport function parseUnitScaleRange(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  SCALE_CHANNELS.forEach((channel: ScaleChannel) => {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      return;\n    }\n\n    const rangeWithExplicit = parseRangeForChannel(channel, model);\n\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  });\n}\n\nfunction getBinStepSignal(model: UnitModel, channel: 'x' | 'y'): SignalRefWrapper {\n  const fieldDef = model.fieldDef(channel);\n\n  if (fieldDef && fieldDef.bin && isBinning(fieldDef.bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, fieldDef.bin);\n\n    // TODO: extract this to be range step signal\n    const sizeType = getSizeType(channel);\n    const sizeSignal = model.getName(sizeType);\n    return new SignalRefWrapper(() => {\n      const updatedName = model.getSignalName(binSignal);\n      const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n      return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n    });\n  }\n  return undefined;\n}\n\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel: ScaleChannel, model: UnitModel): Explicit<VgRange> {\n  const specifiedScale = model.specifiedScales[channel];\n  const {size} = model;\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return makeExplicit(specifiedScale[property]);\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n        }\n      }\n    }\n  }\n\n  if (channel === X || channel === Y) {\n    const sizeChannel = channel === X ? 'width' : 'height';\n    const sizeValue = size[sizeChannel];\n    if (isStep(sizeValue)) {\n      if (hasDiscreteDomain(scaleType)) {\n        return makeExplicit({step: sizeValue.step});\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    }\n  }\n\n  return makeImplicit(defaultRange(channel, model));\n}\n\nfunction parseScheme(scheme: Scheme): SchemeConfig {\n  if (isExtendedScheme(scheme)) {\n    return {\n      scheme: scheme.name,\n      ...util.omit(scheme, ['name'])\n    };\n  }\n  return {scheme: scheme};\n}\n\nfunction defaultRange(channel: ScaleChannel, model: UnitModel): VgRange {\n  const {size, config, mark} = model;\n\n  const getSignalName = model.getSignalName.bind(model);\n\n  const {type} = model.fieldDef(channel);\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n\n  const {domain} = model.specifiedScales[channel];\n\n  switch (channel) {\n    case X:\n    case Y: {\n      // If there is no explicit width/height for discrete x/y scales\n      if (util.contains(['point', 'band'], scaleType)) {\n        if (channel === X && !size.width) {\n          const w = getViewConfigDiscreteSize(config.view, 'width');\n          if (isStep(w)) {\n            return w;\n          }\n        } else if (channel === Y && !size.height) {\n          const h = getViewConfigDiscreteSize(config.view, 'height');\n          if (isStep(h)) {\n            return h;\n          }\n        }\n      }\n\n      // If step is null, use zero to width or height.\n      // Note that these range signals are temporary\n      // as they can be merged and renamed.\n      // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)\n      // We will later replace these temporary names with\n      // the final name in assembleScaleRange()\n\n      const sizeType = getSizeType(channel);\n      const sizeSignal = model.getName(sizeType);\n\n      if (channel === Y && hasContinuousDomain(scaleType)) {\n        // For y continuous scale, we have to start from the height as the bottom part has the max value.\n        return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n      } else {\n        return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n      }\n    }\n    case SIZE: {\n      // TODO: support custom rangeMin, rangeMax\n      const zero = model.component.scales[channel].get('zero');\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, size, model, config);\n      if (isContinuousToDiscrete(scaleType)) {\n        return interpolateRange(\n          rangeMin,\n          rangeMax,\n          defaultContinuousToDiscreteCount(scaleType, config, domain, channel)\n        );\n      } else {\n        return [rangeMin, rangeMax];\n      }\n    }\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n      }\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nexport function defaultContinuousToDiscreteCount(\n  scaleType: 'quantile' | 'quantize' | 'threshold',\n  config: Config,\n  domain: Domain,\n  channel: Channel\n) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin: number, rangeMax: number | SignalRef, cardinality: number): SignalRef {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = isSignalRef(rangeMax) ? rangeMax.signal : rangeMax;\n    const step = `(${rMax} - ${rangeMin}) / (${cardinality} - 1)`;\n    return `sequence(${rangeMin}, ${rangeMax} + ${step}, ${step})`;\n  };\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {signal: f()};\n  }\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean, config: Config) {\n  if (zero) {\n    return 0;\n  }\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(mark: Mark, size: LayoutSizeMixins, model: UnitModel, config: Config): number | SignalRef {\n  const xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n\n  switch (mark) {\n    case 'bar':\n    case 'tick': {\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      const min = minXYStep(size, xyStepSignals, config.view);\n\n      if (isNumber(min)) {\n        return min - 1;\n      } else {\n        return new SignalRefWrapper(() => `${min.signal} - 1`);\n      }\n    }\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle': {\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      const pointStep = minXYStep(size, xyStepSignals, config.view);\n      if (isNumber(pointStep)) {\n        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n      } else {\n        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n      }\n    }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(\n  size: LayoutSizeMixins,\n  xyStepSignals: {x?: SignalRefWrapper; y?: SignalRefWrapper},\n  viewConfig: ViewConfig\n): number | SignalRef {\n  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(() => {\n      const exprs = [\n        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,\n        xyStepSignals.y ? xyStepSignals.y.signal : heightStep\n      ];\n      return `min(${exprs.join(', ')})`;\n    });\n  }\n\n  return Math.min(widthStep, heightStep);\n}\n"]}