{"version":3,"file":"timeunit.js","sourceRoot":"","sources":["../../../../src/compile/data/timeunit.ts"],"names":[],"mappings":"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","sourcesContent":["import {getSecondaryRangeChannel} from '../../channel';\nimport {hasBand, vgField} from '../../channeldef';\nimport {fieldExpr} from '../../timeunit';\nimport {TimeUnitTransform} from '../../transform';\nimport {Dict, duplicate, hash, keys, vals} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {isUnitModel, ModelWithField} from '../model';\nimport {DataFlowNode} from './dataflow';\n\nexport type TimeUnitComponent = TimeUnitTransform & {\n  /** whether to output time unit as a band (generate two formula including start and end) */\n  band?: boolean;\n};\n\nexport class TimeUnitNode extends DataFlowNode {\n  public clone() {\n    return new TimeUnitNode(null, duplicate(this.formula));\n  }\n\n  constructor(parent: DataFlowNode, private formula: Dict<TimeUnitComponent>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const formula = model.reduceFieldDef(\n      (timeUnitComponent: TimeUnitComponent, fieldDef, channel) => {\n        const {timeUnit, field} = fieldDef;\n\n        const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n\n        const band = isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.markDef, model.config);\n\n        if (timeUnit) {\n          const as = vgField(fieldDef, {forAs: true});\n          timeUnitComponent[hash({as, timeUnit, field})] = {\n            as,\n            timeUnit,\n            field,\n            ...(band ? {band: true} : {})\n          };\n        }\n        return timeUnitComponent;\n      },\n      {} as Dict<TimeUnitComponent>\n    );\n\n    if (keys(formula).length === 0) {\n      return null;\n    }\n\n    return new TimeUnitNode(parent, formula);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: TimeUnitTransform) {\n    const component = {...t};\n\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n  public merge(other: TimeUnitNode) {\n    this.formula = {...this.formula};\n\n    // if the same hash happen twice, merge \"band\"\n    for (const key in other.formula) {\n      if (!this.formula[key] || other.formula[key].band) {\n        // copy if it's not a duplicate or if we need to include copy band over\n        this.formula[key] = other.formula[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  public producedFields() {\n    return new Set(vals(this.formula).map(f => f.as));\n  }\n\n  public dependentFields() {\n    return new Set(vals(this.formula).map(f => f.field));\n  }\n\n  public hash() {\n    return `TimeUnit ${hash(this.formula)}`;\n  }\n\n  public assemble() {\n    const transforms: VgFormulaTransform[] = [];\n\n    for (const f of vals(this.formula)) {\n      const {timeUnit, field, as, band} = f;\n      transforms.push({\n        type: 'formula',\n        as,\n        expr: fieldExpr(timeUnit, field)\n      });\n\n      if (band) {\n        transforms.push({\n          type: 'formula',\n          as: as + '_end',\n          expr: fieldExpr(timeUnit, field, {end: true})\n        });\n      }\n    }\n\n    return transforms;\n  }\n}\n"]}