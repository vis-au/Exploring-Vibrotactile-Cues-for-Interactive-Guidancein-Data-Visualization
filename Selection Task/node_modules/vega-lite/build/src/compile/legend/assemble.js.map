{"version":3,"file":"assemble.js","sourceRoot":"","sources":["../../../../src/compile/legend/assemble.ts"],"names":[],"mappings":"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","sourcesContent":["import {Legend as VgLegend, LegendEncode} from 'vega';\nimport {keys, stringify, vals} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {Model} from '../model';\nimport {LegendComponent} from './component';\nimport {mergeLegendComponent} from './parse';\n\nfunction setLegendEncode(\n  legend: VgLegend,\n  part: keyof LegendEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | VgValueRef[]\n) {\n  legend.encode = legend.encode || {};\n  legend.encode[part] = legend.encode[part] || {};\n  legend.encode[part].update = legend.encode[part].update || {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (legend.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleLegends(model: Model): VgLegend[] {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain: {[domainHash: string]: LegendComponent[]} = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.get('domains'));\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  return vals(legendByDomain)\n    .flat()\n    .map((legendCmpt: LegendComponent) => {\n      const {labelExpr, ...legend} = legendCmpt.combine();\n\n      if (legend.encode && legend.encode.symbols) {\n        const out = legend.encode.symbols.update;\n        if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n          // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n          out.stroke = {value: 'transparent'};\n        }\n\n        if (legend.fill) {\n          // If top-level fill is defined, for non color channel's legend, we need remove fill.\n          delete out.fill;\n        }\n      }\n\n      if (labelExpr !== undefined) {\n        let expr = labelExpr;\n        if (\n          legend.encode &&\n          legend.encode.labels &&\n          legend.encode.labels.update &&\n          isSignalRef(legend.encode.labels.update.text)\n        ) {\n          expr = labelExpr.replace('datum.label', legend.encode.labels.update.text.signal);\n        }\n\n        setLegendEncode(legend, 'labels', 'text', {signal: expr});\n      }\n\n      return legend;\n    });\n}\n"]}